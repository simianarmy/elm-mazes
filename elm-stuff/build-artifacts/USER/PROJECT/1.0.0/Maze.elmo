Elm.Maze = Elm.Maze || {};
Elm.Maze.make = function (_elm) {
   "use strict";
   _elm.Maze = _elm.Maze || {};
   if (_elm.Maze.values)
   return _elm.Maze.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   $moduleName = "Maze",
   $AldousBroder = Elm.AldousBroder.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $BinaryTree = Elm.BinaryTree.make(_elm),
   $Cell = Elm.Cell.make(_elm),
   $ColoredGrid = Elm.ColoredGrid.make(_elm),
   $DistanceGrid = Elm.DistanceGrid.make(_elm),
   $Grid = Elm.Grid.make(_elm),
   $Html = Elm.Html.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Random = Elm.Random.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Sidewinder = Elm.Sidewinder.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Wilsons = Elm.Wilsons.make(_elm);
   var algToString = function (algType) {
      return function () {
         switch (algType.ctor)
         {case "AldousBroder":
            return "Aldous-Broder";
            case "BinaryTree":
            return "Binary Tree";
            case "Sidewinder":
            return "Sidewinder";
            case "Wilsons":
            return "Wilsons";}
         _U.badCase($moduleName,
         "between lines 99 and 103");
      }();
   };
   var getAlgFn = function (algType) {
      return function () {
         switch (algType.ctor)
         {case "AldousBroder":
            return $AldousBroder.on;
            case "BinaryTree":
            return $BinaryTree.on;
            case "Sidewinder":
            return $Sidewinder.on;
            case "Wilsons":
            return $Wilsons.on;}
         _U.badCase($moduleName,
         "between lines 91 and 95");
      }();
   };
   var viewDistances = function (maze) {
      return function () {
         var goal = $Grid.toValidCell(A3($Grid.getCell,
         maze.grid,
         maze.grid.rows,
         1));
         var root = $Grid.center(maze.grid);
         var dgrid = A2($DistanceGrid.createDistanceGrid,
         maze.grid,
         root);
         var pathDistances = A3($DistanceGrid.pathTo,
         maze.grid,
         root,
         goal);
         var pathGrid = _U.replace([["dists"
                                    ,pathDistances]],
         dgrid);
         var longDistances = A2($DistanceGrid.longestPath,
         maze.grid,
         root);
         var longGrid = _U.replace([["dists"
                                    ,longDistances]],
         dgrid);
         var rootStr = $Cell.cellToString(root);
         return A2($Html.div,
         _L.fromArray([]),
         _L.fromArray([A2($Html.br,
                      _L.fromArray([]),
                      _L.fromArray([]))
                      ,$Html.text(A2($Basics._op["++"],
                      "Shortest path from ",
                      A2($Basics._op["++"],
                      rootStr,
                      " to SW corner:")))
                      ,A2($Html.pre,
                      _L.fromArray([]),
                      _L.fromArray([$Html.text($DistanceGrid.viewDistances(pathGrid))]))]));
      }();
   };
   var view = function (maze) {
      return function () {
         var root = $Grid.center(maze.grid);
         var coloredGrid = A2($ColoredGrid.createColoredGrid,
         maze.grid,
         root);
         return A2($Html.div,
         _L.fromArray([]),
         _L.fromArray([$Html.text(A2($Basics._op["++"],
                      algToString(maze.alg),
                      " algorithm"))
                      ,$Html.fromElement(A2($ColoredGrid.view,
                      coloredGrid,
                      30))]));
      }();
   };
   var updateSize = F3(function (maze,
   width,
   height) {
      return _U.replace([["grid"
                         ,getAlgFn(maze.alg)(A3($Grid.createGrid,
                         width,
                         height,
                         $Grid.nextSeed(maze.grid)))]],
      maze);
   });
   var update = function (maze) {
      return _U.replace([["grid"
                         ,getAlgFn(maze.alg)($Grid.update(maze.grid))]],
      maze);
   };
   var init = F4(function (algType,
   width,
   height,
   seed) {
      return function () {
         var algfn = getAlgFn(algType);
         var grid = algfn(A3($Grid.createGrid,
         width,
         height,
         seed));
         return {_: {}
                ,alg: algType
                ,grid: grid};
      }();
   });
   var Maze = F2(function (a,b) {
      return {_: {}
             ,alg: b
             ,grid: a};
   });
   var AlgAttr = F2(function (a,
   b) {
      return {_: {}
             ,alg: a
             ,name: b};
   });
   var Wilsons = {ctor: "Wilsons"};
   var AldousBroder = {ctor: "AldousBroder"};
   var Sidewinder = {ctor: "Sidewinder"};
   var defaultAlgorithm = Sidewinder;
   var BinaryTree = {ctor: "BinaryTree"};
   var algorithms = _L.fromArray([{_: {}
                                  ,alg: BinaryTree
                                  ,name: algToString(BinaryTree)}
                                 ,{_: {}
                                  ,alg: Sidewinder
                                  ,name: algToString(Sidewinder)}
                                 ,{_: {}
                                  ,alg: AldousBroder
                                  ,name: algToString(AldousBroder)}
                                 ,{_: {}
                                  ,alg: Wilsons
                                  ,name: algToString(Wilsons)}]);
   var algByName = function (str) {
      return function () {
         var res = $List.head(A2($List.filter,
         function (a) {
            return _U.eq(a.name,str);
         },
         algorithms));
         return function () {
            switch (res.ctor)
            {case "Just":
               return res._0.alg;}
            return Sidewinder;
         }();
      }();
   };
   _elm.Maze.values = {_op: _op
                      ,BinaryTree: BinaryTree
                      ,Sidewinder: Sidewinder
                      ,AldousBroder: AldousBroder
                      ,Wilsons: Wilsons
                      ,AlgAttr: AlgAttr
                      ,Maze: Maze
                      ,defaultAlgorithm: defaultAlgorithm
                      ,init: init
                      ,update: update
                      ,updateSize: updateSize
                      ,view: view
                      ,viewDistances: viewDistances
                      ,algorithms: algorithms
                      ,getAlgFn: getAlgFn
                      ,algToString: algToString
                      ,algByName: algByName};
   return _elm.Maze.values;
};