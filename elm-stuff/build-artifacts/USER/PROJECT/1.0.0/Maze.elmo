Elm.Maze = Elm.Maze || {};
Elm.Maze.make = function (_elm) {
   "use strict";
   _elm.Maze = _elm.Maze || {};
   if (_elm.Maze.values)
   return _elm.Maze.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   $moduleName = "Maze",
   $AldousBroder = Elm.AldousBroder.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $BinaryTree = Elm.BinaryTree.make(_elm),
   $Cell = Elm.Cell.make(_elm),
   $ColoredGrid = Elm.ColoredGrid.make(_elm),
   $DistanceGrid = Elm.DistanceGrid.make(_elm),
   $Grid = Elm.Grid.make(_elm),
   $Html = Elm.Html.make(_elm),
   $HuntAndKill = Elm.HuntAndKill.make(_elm),
   $List = Elm.List.make(_elm),
   $Mask = Elm.Mask.make(_elm),
   $MaskedGrid = Elm.MaskedGrid.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $RecursiveBacktracker = Elm.RecursiveBacktracker.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Sidewinder = Elm.Sidewinder.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $Wilsons = Elm.Wilsons.make(_elm);
   var algToString = function (algType) {
      return function () {
         switch (algType.ctor)
         {case "AldousBroder":
            return "Aldous-Broder";
            case "BinaryTree":
            return "Binary Tree";
            case "HuntAndKill":
            return "Hunt - Kill";
            case "RecursiveBacktracker":
            return "Recursive Backtracker";
            case "Sidewinder":
            return "Sidewinder";
            case "Wilsons":
            return "Wilsons";}
         _U.badCase($moduleName,
         "between lines 123 and 129");
      }();
   };
   var getAlgFn = function (algType) {
      return function () {
         switch (algType.ctor)
         {case "AldousBroder":
            return $AldousBroder.on;
            case "BinaryTree":
            return $BinaryTree.on;
            case "HuntAndKill":
            return $HuntAndKill.on;
            case "RecursiveBacktracker":
            return $RecursiveBacktracker.on;
            case "Sidewinder":
            return $Sidewinder.on;
            case "Wilsons":
            return $Wilsons.on;}
         _U.badCase($moduleName,
         "between lines 113 and 119");
      }();
   };
   var viewDistances = function (maze) {
      return function () {
         var goal = $Grid.toValidCell(A3($Grid.getCell,
         maze.grid,
         maze.grid.rows,
         1));
         var root = $Grid.center(maze.grid);
         var dgrid = A2($DistanceGrid.createDistanceGrid,
         maze.grid,
         root);
         var pathDistances = A3($DistanceGrid.pathTo,
         maze.grid,
         root,
         goal);
         var pathGrid = _U.replace([["dists"
                                    ,pathDistances]],
         dgrid);
         var longDistances = A2($DistanceGrid.longestPath,
         maze.grid,
         root);
         var longGrid = _U.replace([["dists"
                                    ,longDistances]],
         dgrid);
         var rootStr = $Cell.cellToString(root);
         return A2($Html.div,
         _L.fromArray([]),
         _L.fromArray([A2($Html.br,
         _L.fromArray([]),
         _L.fromArray([]))]));
      }();
   };
   var view = function (maze) {
      return function () {
         var root = $Grid.center(maze.grid);
         var coloredGrid = A2($ColoredGrid.createColoredGrid,
         maze.grid,
         root);
         return A2($Html.div,
         _L.fromArray([]),
         _L.fromArray([$Html.text(A2($Basics._op["++"],
                      algToString(maze.alg),
                      " algorithm"))
                      ,A2($Html.br,
                      _L.fromArray([]),
                      _L.fromArray([]))
                      ,$Html.text(A2($Basics._op["++"],
                      $Basics.toString($List.length($Grid.deadEnds(maze.grid))),
                      " deadends"))
                      ,$Html.fromElement(A2($ColoredGrid.view,
                      coloredGrid,
                      30))]));
      }();
   };
   var updateSize = F3(function (maze,
   width,
   height) {
      return function () {
         var grid$ = $Grid.updateRnd(maze.grid);
         var grid$$ = _U.replace([["rows"
                                  ,height]
                                 ,["cols",width]],
         grid$);
         return _U.replace([["grid"
                            ,getAlgFn(maze.alg)($Grid.update(grid$$))]],
         maze);
      }();
   });
   var update = function (maze) {
      return _U.replace([["grid"
                         ,getAlgFn(maze.alg)($Grid.update(maze.grid))]],
      maze);
   };
   var init = F4(function (algType,
   width,
   height,
   seed) {
      return function () {
         var mask = A2($Mask.createMask,
         width,
         height);
         var mask$ = A2($Mask.mset,
         mask,
         _L.fromArray([{ctor: "_Tuple2"
                       ,_0: {ctor: "_Tuple2"
                            ,_0: 0
                            ,_1: 0}
                       ,_1: false}
                      ,{ctor: "_Tuple2"
                       ,_0: {ctor: "_Tuple2"
                            ,_0: 2
                            ,_1: 2}
                       ,_1: false}
                      ,{ctor: "_Tuple2"
                       ,_0: {ctor: "_Tuple2"
                            ,_0: 4
                            ,_1: 4}
                       ,_1: false}]));
         var algfn = getAlgFn(algType);
         var grid = algfn(A2($MaskedGrid.createGrid,
         mask$,
         seed));
         return {_: {}
                ,alg: algType
                ,grid: grid};
      }();
   });
   var Maze = F2(function (a,b) {
      return {_: {}
             ,alg: b
             ,grid: a};
   });
   var AlgAttr = F2(function (a,
   b) {
      return {_: {}
             ,alg: a
             ,name: b};
   });
   var RecursiveBacktracker = {ctor: "RecursiveBacktracker"};
   var defaultAlgorithm = RecursiveBacktracker;
   var HuntAndKill = {ctor: "HuntAndKill"};
   var Wilsons = {ctor: "Wilsons"};
   var AldousBroder = {ctor: "AldousBroder"};
   var Sidewinder = {ctor: "Sidewinder"};
   var BinaryTree = {ctor: "BinaryTree"};
   var algorithms = _L.fromArray([{_: {}
                                  ,alg: BinaryTree
                                  ,name: algToString(BinaryTree)}
                                 ,{_: {}
                                  ,alg: Sidewinder
                                  ,name: algToString(Sidewinder)}
                                 ,{_: {}
                                  ,alg: AldousBroder
                                  ,name: algToString(AldousBroder)}
                                 ,{_: {}
                                  ,alg: Wilsons
                                  ,name: algToString(Wilsons)}
                                 ,{_: {}
                                  ,alg: HuntAndKill
                                  ,name: algToString(HuntAndKill)}
                                 ,{_: {}
                                  ,alg: RecursiveBacktracker
                                  ,name: algToString(RecursiveBacktracker)}]);
   var algByName = function (str) {
      return function () {
         var res = $List.head(A2($List.filter,
         function (a) {
            return _U.eq(a.name,str);
         },
         algorithms));
         return function () {
            switch (res.ctor)
            {case "Just":
               return res._0.alg;}
            return Sidewinder;
         }();
      }();
   };
   _elm.Maze.values = {_op: _op
                      ,BinaryTree: BinaryTree
                      ,Sidewinder: Sidewinder
                      ,AldousBroder: AldousBroder
                      ,Wilsons: Wilsons
                      ,HuntAndKill: HuntAndKill
                      ,RecursiveBacktracker: RecursiveBacktracker
                      ,AlgAttr: AlgAttr
                      ,Maze: Maze
                      ,defaultAlgorithm: defaultAlgorithm
                      ,init: init
                      ,update: update
                      ,updateSize: updateSize
                      ,view: view
                      ,viewDistances: viewDistances
                      ,algorithms: algorithms
                      ,getAlgFn: getAlgFn
                      ,algToString: algToString
                      ,algByName: algByName};
   return _elm.Maze.values;
};