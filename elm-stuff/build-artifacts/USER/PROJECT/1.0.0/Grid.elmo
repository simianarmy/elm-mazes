Elm.Grid = Elm.Grid || {};
Elm.Grid.make = function (_elm) {
   "use strict";
   _elm.Grid = _elm.Grid || {};
   if (_elm.Grid.values)
   return _elm.Grid.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   $moduleName = "Grid",
   $Array = Elm.Array.make(_elm),
   $Basics = Elm.Basics.make(_elm),
   $Cell = Elm.Cell.make(_elm),
   $Color = Elm.Color.make(_elm),
   $Graphics$Collage = Elm.Graphics.Collage.make(_elm),
   $Graphics$Element = Elm.Graphics.Element.make(_elm),
   $List = Elm.List.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Random = Elm.Random.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Rnd = Elm.Rnd.make(_elm),
   $Set = Elm.Set.make(_elm),
   $Signal = Elm.Signal.make(_elm),
   $String = Elm.String.make(_elm);
   var RowAscii = F2(function (a,
   b) {
      return {_: {}
             ,bottom: b
             ,top: a};
   });
   var cellBackgroundColor = F2(function (grid,
   cell) {
      return $Color.white;
   });
   var cellToAscii = F2(function (grid,
   cell) {
      return " ";
   });
   var toTitle = function (grid) {
      return A2($Basics._op["++"],
      $Basics.toString(grid.rows),
      A2($Basics._op["++"],
      " X ",
      A2($Basics._op["++"],
      $Basics.toString(grid.cols),
      " Grid")));
   };
   var cellToList = function (cell) {
      return function () {
         switch (cell.ctor)
         {case "Just":
            return _L.fromArray([cell._0]);
            case "Nothing":
            return _L.fromArray([]);}
         _U.badCase($moduleName,
         "between lines 247 and 249");
      }();
   };
   var gridIndex = F3(function (grid,
   row,
   col) {
      return grid.cols * (row - 1) + col;
   });
   var cellIndex = F2(function (grid,
   cell) {
      return grid.cols * (cell.row - 1) + cell.col;
   });
   var size = function (grid) {
      return grid.rows * grid.cols;
   };
   var rowCells = F2(function (grid,
   row) {
      return A2($List.filter,
      function (c) {
         return _U.eq(c.row,row);
      },
      grid.cells);
   });
   var unlinkCells = F4(function (grid,
   cell,
   cellToUnlink,
   bidi) {
      return function () {
         var unlinkCell = F2(function (cell1,
         cell2) {
            return _U.replace([["links"
                               ,A2($Set.remove,
                               cell2.id,
                               cell1.links)]],
            cell1);
         });
         var unlinkMatched = function (c) {
            return _U.eq(c.id,
            cell.id) ? A2(unlinkCell,
            c,
            cellToUnlink) : bidi ? A2(unlinkCell,
            cellToUnlink,
            cell) : c;
         };
         return _U.replace([["cells"
                            ,A2($List.map,
                            unlinkMatched,
                            grid.cells)]],
         grid);
      }();
   });
   var linkCells = F4(function (grid,
   cell,
   cellToLink,
   bidi) {
      return function () {
         var linkCell = F2(function (cell1,
         cell2) {
            return _U.replace([["links"
                               ,A2($Set.insert,
                               cell2.id,
                               cell1.links)]],
            cell1);
         });
         var linkMatched = function (c) {
            return _U.eq(c.id,
            cell.id) ? A2(linkCell,
            c,
            cellToLink) : bidi && _U.eq(c.id,
            cellToLink.id) ? A2(linkCell,
            c,
            cell) : c;
         };
         return _U.replace([["cells"
                            ,A2($List.map,
                            linkMatched,
                            grid.cells)]],
         grid);
      }();
   });
   var deadEnds = function (grid) {
      return A2($List.filter,
      function (c) {
         return _U.eq($List.length($Set.toList(c.links)),
         1);
      },
      grid.cells);
   };
   var isValidCell = function (cell) {
      return function () {
         switch (cell.ctor)
         {case "Just": return true;
            case "Nothing": return false;}
         _U.badCase($moduleName,
         "between lines 127 and 129");
      }();
   };
   var toValidCell = function (cell) {
      return function () {
         switch (cell.ctor)
         {case "Just": return cell._0;
            case "Nothing":
            return A2($Cell.createCell,
              -1,
              -1);}
         _U.badCase($moduleName,
         "between lines 121 and 123");
      }();
   };
   var getCell = F3(function (grid,
   row,
   col) {
      return _U.cmp(row,
      grid.rows) > 0 || (_U.cmp(col,
      grid.cols) > 0 || (_U.cmp(row,
      0) < 1 || _U.cmp(col,
      0) < 1)) ? $Maybe.Nothing : $Array.get(A3(gridIndex,
      grid,
      row,
      col) - 1)($Array.fromList(grid.cells));
   });
   var north = F2(function (grid,
   cell) {
      return A3(getCell,
      grid,
      cell.row - 1,
      cell.col);
   });
   var south = F2(function (grid,
   cell) {
      return A3(getCell,
      grid,
      cell.row + 1,
      cell.col);
   });
   var west = F2(function (grid,
   cell) {
      return A3(getCell,
      grid,
      cell.row,
      cell.col - 1);
   });
   var east = F2(function (grid,
   cell) {
      return A3(getCell,
      grid,
      cell.row,
      cell.col + 1);
   });
   var neighbors = F2(function (grid,
   cell) {
      return function () {
         var e = A2(east,grid,cell);
         var w = A2(west,grid,cell);
         var s = A2(south,grid,cell);
         var n = A2(north,grid,cell);
         return $List.concat(_L.fromArray([cellToList(n)
                                          ,cellToList(s)
                                          ,cellToList(w)
                                          ,cellToList(e)]));
      }();
   });
   var filterNeighbors = F3(function (pred,
   grid,
   cell) {
      return $List.filter(pred)(A2(neighbors,
      grid,
      cell));
   });
   var toAscii = F2(function (cellViewer,
   grid) {
      return function () {
         var cellToString = F2(function (cell,
         ascii) {
            return function () {
               var curbottom = ascii.bottom;
               var curtop = ascii.top;
               var south_boundary = A2($Cell.isLinked,
               cell,
               toValidCell(A2(south,
               grid,
               cell))) ? "   " : "---";
               var east_boundary = A2($Cell.isLinked,
               cell,
               toValidCell(A2(east,
               grid,
               cell))) ? " " : "|";
               var body = A2($Basics._op["++"],
               " ",
               A2($Basics._op["++"],
               A2(cellViewer,grid,cell),
               " "));
               return _U.replace([["top"
                                  ,A2($Basics._op["++"],
                                  curtop,
                                  A2($Basics._op["++"],
                                  body,
                                  east_boundary))]
                                 ,["bottom"
                                  ,A2($Basics._op["++"],
                                  curbottom,
                                  A2($Basics._op["++"],
                                  south_boundary,
                                  "+"))]],
               ascii);
            }();
         });
         var rowToStrings = function (row) {
            return function () {
               var rowascii = {_: {}
                              ,bottom: "+"
                              ,top: "|"};
               var finalascii = A3($List.foldl,
               cellToString,
               rowascii,
               A2(rowCells,grid,row));
               return A2($Basics._op["++"],
               finalascii.top,
               A2($Basics._op["++"],
               "\n",
               A2($Basics._op["++"],
               finalascii.bottom,
               "\n")));
            }();
         };
         return A2($Basics._op["++"],
         "+",
         A2($Basics._op["++"],
         A2($String.repeat,
         grid.cols,
         "---+"),
         A2($Basics._op["++"],
         "\n",
         $String.concat(A2($List.map,
         rowToStrings,
         _L.range(1,grid.rows))))));
      }();
   });
   var center = function (grid) {
      return toValidCell(A3(getCell,
      grid,
      grid.rows / 2 | 0,
      grid.cols / 2 | 0));
   };
   var cellIdToCell = F2(function (grid,
   cellid) {
      return function () {
         var col = $Basics.snd(cellid);
         var row = $Basics.fst(cellid);
         return toValidCell(A3(getCell,
         grid,
         row,
         col));
      }();
   });
   var linkedCells = F2(function (grid,
   cell) {
      return A2($List.map,
      cellIdToCell(grid),
      $Set.toList(cell.links));
   });
   var view = F3(function (cellPainter,
   grid,
   cellSize) {
      return function () {
         var cellToRect = function (cell) {
            return $Graphics$Collage.square($Basics.toFloat(cellSize));
         };
         var cellBackground = F2(function (style,
         cell) {
            return function () {
               var halfSize = $Basics.toFloat(cellSize) / 2.0;
               var cx = $Basics.toFloat((cell.col - 1) * cellSize) + halfSize;
               var cy = $Basics.toFloat($Basics.negate(cell.row - 1) * cellSize) - halfSize;
               var bgRect = A2($Graphics$Collage.filled,
               A2(cellPainter,grid,cell),
               cellToRect(cell));
               return A2($Graphics$Collage.move,
               {ctor: "_Tuple2",_0: cx,_1: cy},
               bgRect);
            }();
         });
         var maybeVisibleLine = F2(function (style,
         _v6) {
            return function () {
               switch (_v6.ctor)
               {case "_Tuple2":
                  return _v6._0 ? _L.fromArray([A2($Graphics$Collage.traced,
                    style,
                    _v6._1)]) : _L.fromArray([]);}
               _U.badCase($moduleName,
               "between lines 69 and 71");
            }();
         });
         var cellWalls = F2(function (style,
         cell) {
            return function () {
               var y2 = $Basics.toFloat($Basics.negate(cell.row) * cellSize);
               var x2 = $Basics.toFloat(cell.col * cellSize);
               var y1 = $Basics.toFloat($Basics.negate(cell.row - 1) * cellSize);
               var x1 = $Basics.toFloat((cell.col - 1) * cellSize);
               return A2($List.concatMap,
               maybeVisibleLine(style),
               _L.fromArray([{ctor: "_Tuple2"
                             ,_0: $Basics.not(isValidCell(A2(north,
                             grid,
                             cell)))
                             ,_1: A2($Graphics$Collage.segment,
                             {ctor: "_Tuple2",_0: x1,_1: y1},
                             {ctor: "_Tuple2"
                             ,_0: x2
                             ,_1: y1})}
                            ,{ctor: "_Tuple2"
                             ,_0: $Basics.not(isValidCell(A2(west,
                             grid,
                             cell)))
                             ,_1: A2($Graphics$Collage.segment,
                             {ctor: "_Tuple2",_0: x1,_1: y1},
                             {ctor: "_Tuple2"
                             ,_0: x1
                             ,_1: y2})}
                            ,{ctor: "_Tuple2"
                             ,_0: $Basics.not(A2($Cell.isLinked,
                             cell,
                             toValidCell(A2(east,
                             grid,
                             cell))))
                             ,_1: A2($Graphics$Collage.segment,
                             {ctor: "_Tuple2",_0: x2,_1: y1},
                             {ctor: "_Tuple2"
                             ,_0: x2
                             ,_1: y2})}
                            ,{ctor: "_Tuple2"
                             ,_0: $Basics.not(A2($Cell.isLinked,
                             cell,
                             toValidCell(A2(south,
                             grid,
                             cell))))
                             ,_1: A2($Graphics$Collage.segment,
                             {ctor: "_Tuple2",_0: x1,_1: y2},
                             {ctor: "_Tuple2"
                             ,_0: x2
                             ,_1: y2})}]));
            }();
         });
         var paintCell = function (cell) {
            return function () {
               var style = _U.replace([["width"
                                       ,2]],
               $Graphics$Collage.defaultLine);
               return $Graphics$Collage.group(A2($List._op["::"],
               A2(cellBackground,style,cell),
               A2(cellWalls,style,cell)));
            }();
         };
         var drawables = A2($List.map,
         paintCell,
         grid.cells);
         var imgHeight = cellSize * grid.rows;
         var oy = $Basics.toFloat(imgHeight) / 2.0;
         var imgWidth = cellSize * grid.cols;
         var ox = $Basics.toFloat($Basics.negate(imgWidth)) / 2.0;
         return A3($Graphics$Collage.collage,
         imgWidth,
         imgHeight,
         _L.fromArray([$Graphics$Collage.move({ctor: "_Tuple2"
                                              ,_0: ox
                                              ,_1: oy})($Graphics$Collage.group(drawables))]));
      }();
   });
   var updateRnd = function (grid) {
      return _U.replace([["rnd"
                         ,$Rnd.refresh(grid.rnd)]],
      grid);
   };
   var randomCell = function (grid) {
      return function () {
         var grid$ = updateRnd(grid);
         var randRow = grid$.rnd.row;
         var randCol = grid$.rnd.col;
         var cell = toValidCell(A3(getCell,
         grid$,
         randRow,
         randCol));
         return {ctor: "_Tuple2"
                ,_0: grid$
                ,_1: cell};
      }();
   };
   var nextSeed = function (grid) {
      return $Rnd.refresh(grid.rnd).seed;
   };
   var createGrid = F3(function (rows,
   cols,
   initSeed) {
      return function () {
         var makeRow = F2(function (cols,
         row) {
            return A2($List.map,
            $Cell.createCell(row),
            _L.range(1,cols));
         });
         return {_: {}
                ,cells: A2($List.concatMap,
                makeRow(cols),
                _L.range(1,rows))
                ,cols: cols
                ,rnd: A3($Rnd.createGridRnd,
                rows,
                cols,
                initSeed)
                ,rows: rows};
      }();
   });
   var update = function (grid) {
      return A2(createGrid,
      grid.rows,
      grid.cols)(nextSeed(grid));
   };
   var Grid = F5(function (a,
   b,
   c,
   d,
   e) {
      return _U.insert("rnd",
      d,
      _U.insert("cells",
      c,
      _U.insert("cols",
      b,
      _U.insert("rows",a,e))));
   });
   _elm.Grid.values = {_op: _op
                      ,Grid: Grid
                      ,createGrid: createGrid
                      ,nextSeed: nextSeed
                      ,updateRnd: updateRnd
                      ,update: update
                      ,view: view
                      ,getCell: getCell
                      ,toValidCell: toValidCell
                      ,isValidCell: isValidCell
                      ,north: north
                      ,south: south
                      ,west: west
                      ,east: east
                      ,center: center
                      ,randomCell: randomCell
                      ,neighbors: neighbors
                      ,deadEnds: deadEnds
                      ,filterNeighbors: filterNeighbors
                      ,linkCells: linkCells
                      ,unlinkCells: unlinkCells
                      ,linkedCells: linkedCells
                      ,rowCells: rowCells
                      ,size: size
                      ,cellIndex: cellIndex
                      ,gridIndex: gridIndex
                      ,cellIdToCell: cellIdToCell
                      ,cellToList: cellToList
                      ,toTitle: toTitle
                      ,cellToAscii: cellToAscii
                      ,cellBackgroundColor: cellBackgroundColor
                      ,RowAscii: RowAscii
                      ,toAscii: toAscii};
   return _elm.Grid.values;
};